(in-package #:kslgui)

(export 'insert-placeholder)
(declaim (ftype (function (ui) (values placeholder &optional)) insert-placeholder))
(defun insert-placeholder (ui)
  (let ((parent (ui-temp-parent ui))
        (initial-index (ui-temp-sibling-index ui)))
    (unless parent
      (error "Can't insert placeholder as root"))
    (let ((placeholder (make-placeholder parent initial-index)))
      (vector-insert (widget-children parent) placeholder initial-index)
      placeholder)))

(export 'delete-placeholder)
(declaim (ftype (function (placeholder) (values &optional)) delete-placeholder))
(defun delete-placeholder (placeholder)
  (let ((parent (placeholder-parent placeholder)))
    (setf (widget-children parent)
      (vector-delete placeholder (widget-children parent))))
  (values))

(export 'initialize-widget)
(declaim (ftype (function (ui widget &key (:z-index t)
                              (:position-type t)
                              (:enabled (or boolean function)))
                          (values &optional))
                initialize-widget))
(defun initialize-widget (ui widget &key z-index position-type (enabled t))
  (let* ((parent (ui-temp-parent ui))
         (yoga-node (yogalayout:node-new-with-config (ui-yoga-config ui))))
    (setf (widget-parent widget) parent)
    (setf (widget-yoga-node widget) yoga-node)
    (setf (widget-yoga-index widget) (ui-temp-sibling-index ui))
    (setf (widget-position-type-computed widget) (init-computed-prop widget position-type))
    (setf (widget-z-index-computed widget) (init-computed-prop widget z-index))
    (setf (widget-enabled-computed widget) (init-computed-prop widget enabled))
    (sdet:make-effect (ui-sdet-context ui)
      (let ((z-index (or (sdet:compute (widget-z-index-computed widget)) :auto))
            (position-type (or (sdet:compute (widget-position-type-computed widget))
                               yogalayout:+position-type-static+)))
        (setf (widget-z-index widget) z-index)
        (yogalayout:node-style-set-position-type (widget-yoga-node widget) position-type)
        (if (and
             (widget-parent widget)
             (not (widget-force-isolated-rendering widget))
             (or (= position-type yogalayout:+position-type-static+) (eq :auto z-index)))
            (setf (widget-rendering-order-cache widget) nil)
            (setf (widget-rendering-order-cache widget) (make-array 0 :adjustable t :fill-pointer 0)))
        (widget-rendering-order-changed widget))
      nil)
    (multiple-value-bind (subscribe notify) (sdet:make-notifier (ui-sdet-context ui))
      (setf (widget-subscribe-layout-changed widget) subscribe)
      (setf (widget-notify-layout-changed widget) notify))
    (multiple-value-bind (get set) (sdet:make-state (ui-sdet-context ui) nil)
      (setf (widget-get-mouse-hover-p widget) get)
      (setf (widget-set-mouse-hover-p widget) set))
    (multiple-value-bind (get set) (sdet:make-state (ui-sdet-context ui) (the (unsigned-byte 3) 0))
      (setf (widget-get-mouse-active-p widget) get)
      (setf (widget-set-mouse-active-p widget) set))
    (if parent
        (progn
         (dotimes (offset (- (length (widget-children parent)) (widget-yoga-index widget)))
           (let ((child (aref (widget-children parent) (+ (widget-yoga-index widget) offset))))
             (etypecase child
               (placeholder (incf (placeholder-index child)))
               (widget (incf (widget-yoga-index child))))))
         (yogalayout:node-insert-child (widget-yoga-node parent) yoga-node (widget-yoga-index widget))
         (vector-insert (widget-children parent) widget (widget-yoga-index widget))
         (incf (ui-temp-sibling-index ui))
         (widget-children-rendering-order-changed parent))
        (if (ui-temp-root ui)
            (error "Root already set while creating new parentless widget.")
            (setf (ui-temp-root ui) widget))))
  (values))

(export 'destroy-widget)
(defun destroy-widget (widget)
  (let ((parent (widget-parent widget)))
    (when parent
          (setf (widget-children parent) (vector-delete widget (widget-children parent)))
          (dotimes (offset (- (length (widget-children parent)) (widget-yoga-index widget)))
            (let ((child (aref (widget-children parent) (+ (widget-yoga-index widget) offset))))
              (etypecase child
                (placeholder (decf (placeholder-index child)))
                (widget (decf (widget-yoga-index child))))))
          (yogalayout:node-remove-child (widget-yoga-node parent) (widget-yoga-node widget))
          (widget-children-rendering-order-changed parent)))
  (yogalayout:node-reset (widget-yoga-node widget))
  (yogalayout:node-free (widget-yoga-node widget)))

(export 'append-children)
(defun append-children (ui widget f)
  (let ((parent (ui-temp-parent ui))
        (previous-sibling-index (ui-temp-sibling-index ui)))
    (setf (ui-temp-sibling-index ui) 0)
    (setf (ui-temp-parent ui) widget)
    (funcall f widget)
    (setf (ui-temp-parent ui) parent)
    (setf (ui-temp-sibling-index ui) previous-sibling-index))
  (values))

(alexandria:define-constant +yoga-style-prop-setter-prefix+ "NODE-STYLE-SET-" :test #'string=)

(export 'make-layout-setting-code)
(defun make-layout-setting-code (ui layout widget-sym)
  `(sdet:make-effect (ui-sdet-context ,ui)
     ,@(mapcar (lambda (stp)
                 (let ((st-set-sym (find-symbol (uiop:strcat +yoga-style-prop-setter-prefix+ (symbol-name (first stp))) '#:yogalayout)))
                   (if st-set-sym
                       `(,st-set-sym (widget-yoga-node ,widget-sym) ,@(rest stp))
                       (error "Unknown Yoga layout setter: ~a." (first stp)))))
           layout)))

(export 'make-layout-setting-lambda)
(defun make-layout-setting-lambda (ui layout)
  (if layout
      (alexandria:with-gensyms (widget)
        `(lambda (,widget)
           ,(make-layout-setting-code ui layout widget)))
      'nil))

(export 'make-children-making-lambda)
(defun make-children-making-lambda (ui children &key let)
  (if children
      (let ((widget (or let (gensym))))
        `(lambda (,widget)
           (declare (ignorable ,widget))
           ,@(mapcar (lambda (child) `(sdet:make-effect (ui-sdet-context ,ui) ,child)) children)))
      'nil))

(defun wsd.test (ui tags widget-sym form)
  (cond
   ((consp form)
     (if (eq 'quote (car form))
         (cadr form)
         (cons (car form) (mapcar (lambda (sub-form)
                                    (wsd.test ui tags widget-sym sub-form)) (cdr form)))))
   ((keywordp form)
     (multiple-value-bind (tag-form tag-known-p) (if tags (gethash form tags) (values nil nil))
       (if tag-known-p
           tag-form
           (case form
             (:hover `(funcall (widget-get-mouse-hover-p ,widget-sym)))
             (:active `(< 0 (funcall (widget-get-mouse-active-p ,widget-sym))))
             (:active-left `(< 0 (logand +active-mouse-button-left+ (funcall (widget-get-mouse-active-p ,widget-sym)))))
             (:active-middle `(< 0 (logand +active-mouse-button-middle+ (funcall (widget-get-mouse-active-p ,widget-sym)))))
             (:active-right `(< 0 (logand +active-mouse-button-right+ (funcall (widget-get-mouse-active-p ,widget-sym)))))
             (:focus `(eq ,widget-sym (keyboard-focus ,ui)))
             (:enabled `(sdet:compute (widget-enabled-computed ,widget-sym)))
             (:disabled `(not (sdet:compute (widget-enabled-computed ,widget-sym))))
             (t (error "WSD: unknown keyword ~a" form))))))
   ((eq 't form) 't)
   (t (error "WSD: can't parse test form ~a" form))))

(export 'wsd)
(defmacro wsd (widget &body branches)
  "COND with conditional keywords :HOVER, :ENABLED etc.
  Conditions include quoting, functions (with arguments processed recursively) and T: (AND :HOVER T '(< 1 2))"
  `(cond ,@(mapcar (lambda (branch)
                     `(,(wsd.test *ui* nil widget (car branch))
                        ,@(cdr branch)))
                   branches)))

(export 'make-computed-prop)
(defun make-computed-prop (val &key let)
  (cond
   ((constantp val) val)
   (t (let ((widget-sym (or let (gensym))))
        `(lambda (,widget-sym)
           (declare (ignorable ,widget-sym))
           (lambda () ,val))))))

(export 'init-computed-prop)
(defun init-computed-prop (widget x)
  (if (typep x 'function)
      (funcall x widget)
      x))

(export 'make-visual-prop)
(defun make-visual-prop (ui vdescr &key let widget-visual)
  (let ((widget (or let (gensym)))
        (vdescr-item-computed (gensym)))
    (if (null vdescr)
        'nil
        `(lambda (,widget)
           (declare (ignorable ,widget))
           ,(if (= 1 (length vdescr))
                `(let ((,vdescr-item-computed (lambda () ,(first vdescr))))
                   (sdet:make-effect (ui-sdet-context ,ui)
                     (setf (,widget-visual ,widget)
                       (update-visual (sdet:compute ,vdescr-item-computed) (,widget-visual ,widget)))
                     nil))
                (let ((forms '()))
                  (loop #:for index #:from 0
                        #:for vdescr-item #:in vdescr
                        #:do (setf forms (cons
                                           `(let ((,vdescr-item-computed (lambda () ,vdescr-item)))
                                              (sdet:make-effect (ui-sdet-context ,ui)
                                                (setf (aref (,widget-visual ,widget) ,index)
                                                  (update-visual (sdet:compute ,vdescr-item-computed) (aref (,widget-visual ,widget) ,index)))
                                                nil))
                                           forms)))
                  `(progn
                    (setf (,widget-visual ,widget) (make-array ,(length vdescr) :initial-element nil))
                    ,@(reverse forms))))
           (values)))))

(export 'run-visual-prop)
(defun run-visual-prop (widget prop)
  (when prop (funcall prop widget))
  (values))
